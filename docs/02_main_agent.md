# Improved Main Agent Implementation

This is a refactored and improved version of the `main.py` file, following best practices and modern Python standards.

```python
#!/usr/bin/env python3
"""
Crypto Trading Signal Agent

This module implements the main agent for the Crypto Trading Agent System,
which orchestrates communication between specialized agents to provide
cryptocurrency trading signals (BUY/SELL/HOLD) based on market data,
news, and sentiment analysis.
"""

import atexit
import logging
import sys
from dataclasses import dataclass
from enum import Enum, auto
from typing import Dict, List, Optional, Union, Any

import os
from dotenv import load_dotenv
from uagents import Agent, Context, Model

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    handlers=[
        logging.StreamHandler(stream=sys.stdout),
        logging.FileHandler(filename="main_agent.log", mode="a"),
    ],
)

logger = logging.getLogger("main_agent")


class AgentError(Exception):
    """Base exception class for agent-related errors."""
    pass


class AgentCommunicationError(AgentError):
    """Exception raised when communication between agents fails."""
    pass


class AgentConfigurationError(AgentError):
    """Exception raised when agent configuration is invalid."""
    pass


class BlockchainType(str, Enum):
    """Supported blockchain types for data requests."""
    ETHEREUM = "ethereum"
    BASE = "base"
    BITCOIN = "bitcoin"
    MATIC = "matic-network"


class InvestorType(str, Enum):
    """Investor types for personalized recommendations."""
    LONG_TERM = "long-term"
    SHORT_TERM = "short-term"
    SPECULATE = "speculate"


class RiskStrategy(str, Enum):
    """Risk strategies for personalized recommendations."""
    CONSERVATIVE = "conservative"
    BALANCED = "balanced"
    AGGRESSIVE = "aggressive"
    SPECULATIVE = "speculative"


class TradingSignal(str, Enum):
    """Trading signals that can be generated by the system."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


# Agent addresses (loaded from environment variables with defaults)
COIN_AGENT = os.getenv("COIN_AGENT_ADDRESS", "agent1qw6cxgq4l8hmnjctm43q97vajrytuwjc2e2n4ncdfpqk6ggxcfmxuwdc9rq")
FGI_AGENT = os.getenv("FGI_AGENT_ADDRESS", "agent1qgzh245lxeaapd32mxlwgdf2607fkt075hymp06rceknjnc2ylznwdv8up7")
REASON_AGENT = os.getenv("REASON_AGENT_ADDRESS", "agent1qwlg48h8sstknk7enc2q44227ahq6dr5mjg0p7z62ca6tfueze38kyrtyl2")
CRYPTONEWS_AGENT = os.getenv("CRYPTONEWS_AGENT_ADDRESS", "agent1q2cq0q3cnhccudx6cym8smvpquafsd99lrwexppuecfrnv90xlrs5lsxw6k")


# Request and Response Models
class CoinRequest(Model):
    """Request model for coin market data."""
    blockchain: str


class CoinResponse(Model):
    """Response model with cryptocurrency market data."""
    name: str
    symbol: str
    current_price: float
    market_cap: float
    total_volume: float
    price_change_24h: float


class CryptonewsRequest(Model):
    """Request model for cryptocurrency news."""
    limit: Optional[int] = 1


class CryptonewsResponse(Model):
    """Response model with cryptocurrency news updates."""
    cryptoupdates: str


class ASI1Request(Model):
    """Request model for ASI1 reasoning agent."""
    query: str


class ASI1Response(Model):
    """Response model from ASI1 reasoning agent with trading decision."""
    decision: str


class FearGreedData(Model):
    """Model representing Fear & Greed Index data for a single day."""
    value: float
    value_classification: str
    timestamp: str


class FGIRequest(Model):
    """Request model for Fear & Greed Index data."""
    limit: Optional[int] = 1


class FGIResponse(Model):
    """Response model with Fear & Greed Index data."""
    data: List[FearGreedData]
    status: str
    timestamp: str


@dataclass
class AgentState:
    """Container for the agent's state during a trading analysis cycle."""
    network: BlockchainType = BlockchainType.BITCOIN
    coin_information: Optional[CoinResponse] = None
    cryptonews_info: Optional[CryptonewsResponse] = None
    fgi_data: Optional[FGIResponse] = None
    investor_type: Optional[InvestorType] = None
    risk_strategy: Optional[RiskStrategy] = None
    user_reason: Optional[str] = None


# Initialize the main agent
def create_main_agent() -> Agent:
    """
    Create and configure the main orchestration agent.
    
    Returns:
        Agent: Configured uAgent instance
    """
    try:
        agent_seed = os.getenv("MAIN_AGENT_SEED", "this_is_main_agent_to_run")
        agent_name = os.getenv("MAIN_AGENT_NAME", "SentimentBased CryptoSellAlerts")
        agent_port = int(os.getenv("MAIN_AGENT_PORT", "8017"))
        
        agent = Agent(
            name=agent_name,
            port=agent_port,
            seed=agent_seed,
            endpoint=[f"http://127.0.0.1:{agent_port}/submit"],
        )
        return agent
    except Exception as e:
        logger.critical(f"Failed to create main agent: {e}")
        raise AgentConfigurationError(f"Could not initialize main agent: {e}")


# Create the agent instance
agent = create_main_agent()

# Initialize agent state
agent_state = AgentState()


@atexit.register
def log_and_exit() -> None:
    """Log when the script is terminated."""
    logger.warning("Script terminated unexpectedly")


def handle_unexpected_exception(exc_type: type, exc_value: Exception, exc_traceback: Any) -> None:
    """
    Global exception handler for uncaught exceptions.
    
    Args:
        exc_type: Type of the exception
        exc_value: Exception instance
        exc_traceback: Traceback object
    """
    logger.critical("Uncaught Exception:", exc_info=(exc_type, exc_value, exc_traceback))


# Set global exception handler
sys.excepthook = handle_unexpected_exception


@agent.on_event("startup")
async def introduce_agent(ctx: Context) -> None:
    """
    Initialize the agent and log startup information.
    
    Args:
        ctx: Agent context
    """
    logger.info(f"Agent started: {ctx.agent.address}")
    print(f"Hello! I'm {agent.name} and my address is {agent.address}.")
    logger.info("Agent startup complete.")


async def get_blockchain_input() -> BlockchainType:
    """
    Get and validate blockchain input from the user.
    
    Returns:
        BlockchainType: Selected blockchain
        
    Raises:
        SystemExit: If user input is invalid
    """
    print(f"Please, confirm the chain to request the data from")
    chain_input = input("Blockchain [ethereum/base/bitcoin/matic-network]? ").lower()
    
    try:
        # Validate the input is a supported blockchain
        if chain_input not in [e.value for e in BlockchainType]:
            print("Unsupported blockchain selected")
            sys.exit(1)
        return BlockchainType(chain_input)
    except ValueError:
        print("Aborted")
        sys.exit(1)


async def get_investor_profile() -> InvestorType:
    """
    Get and validate investor profile input from the user.
    
    Returns:
        InvestorType: Selected investor profile
        
    Raises:
        SystemExit: If user input is invalid
    """
    print(f"Please, confirm if you long-term or short-term investor?")
    investor_input = input("Investor [long-term/short-term/speculate]: ").lower()
    
    try:
        if investor_input not in [e.value for e in InvestorType]:
            print("Unsupported investor type selected")
            sys.exit(1)
        return InvestorType(investor_input)
    except ValueError:
        print("Aborted")
        sys.exit(1)


async def get_risk_strategy() -> RiskStrategy:
    """
    Get and validate risk strategy input from the user.
    
    Returns:
        RiskStrategy: Selected risk strategy
        
    Raises:
        SystemExit: If user input is invalid
    """
    print(f"Please, confirm your risk strategy for investments?")
    risk_input = input("Risk strategy [conservative/balanced/aggressive/speculative]: ").lower()
    
    try:
        if risk_input not in [e.value for e in RiskStrategy]:
            print("Unsupported risk strategy selected")
            sys.exit(1)
        return RiskStrategy(risk_input)
    except ValueError:
        print("Aborted")
        sys.exit(1)


@agent.on_interval(period=24 * 60 * 60.0)  # Runs every 24 hours
async def check_coin(ctx: Context) -> None:
    """
    Request market data for the monitored coin once a day.
    
    Args:
        ctx: Agent context
    """
    try:
        # Get blockchain selection from user
        blockchain = await get_blockchain_input()
        agent_state.network = blockchain
        
        # Request coin information
        await ctx.send(COIN_AGENT, CoinRequest(blockchain=blockchain.value))
        logger.info(f"Sent CoinRequest for {blockchain.value}")
    except Exception as e:
        logger.error(f"Failed to send request: {e}")
        raise AgentCommunicationError(f"Failed to communicate with Coin Agent: {e}")


@agent.on_message(model=CoinResponse)
async def handle_coin_response(ctx: Context, sender: str, msg: CoinResponse) -> None:
    """
    Handle coin market data and request crypto news.
    
    Args:
        ctx: Agent context
        sender: Sender agent address
        msg: Coin market data response
    """
    logger.info(f"Received CoinResponse from {sender}")
    
    # Update agent state with coin information
    agent_state.coin_information = msg
    
    try:
        # Request crypto news
        await ctx.send(CRYPTONEWS_AGENT, CryptonewsRequest())
        logger.info("Sent CryptonewsRequest")
    except Exception as e:
        logger.error(f"Error sending CryptonewsRequest: {e}")
        raise AgentCommunicationError(f"Failed to communicate with Cryptonews Agent: {e}")


@agent.on_message(model=CryptonewsResponse)
async def handle_cryptonews_response(ctx: Context, sender: str, msg: CryptonewsResponse) -> None:
    """
    Handle cryptonews market data and request Fear & Greed Index.
    
    Args:
        ctx: Agent context
        sender: Sender agent address
        msg: Crypto news response
    """
    logger.info(f"Received CryptonewsResponse from {sender}")
    
    # Update agent state with crypto news
    agent_state.cryptonews_info = msg
    
    try:
        # Request Fear & Greed Index data
        await ctx.send(FGI_AGENT, FGIRequest())
        logger.info("Sent FGIRequest")
    except Exception as e:
        logger.error(f"Error sending FGIRequest: {e}")
        raise AgentCommunicationError(f"Failed to communicate with FGI Agent: {e}")


@agent.on_message(model=FGIResponse)
async def handle_fgi_response(ctx: Context, sender: str, msg: FGIResponse) -> None:
    """
    Analyze FGI data and determine whether to issue a SELL/BUY or HOLD alert.
    
    Args:
        ctx: Agent context
        sender: Sender agent address
        msg: Fear & Greed Index response
    """
    logger.info(f"Received FGIResponse from {sender}")
    
    # Update agent state with FGI data
    agent_state.fgi_data = msg
    
    try:
        # Get user investor profile and risk strategy
        agent_state.investor_type = await get_investor_profile()
        agent_state.risk_strategy = await get_risk_strategy()
        
        # Get additional context from user
        agent_state.user_reason = input("Any particular reason why you would like to perform Buy/Sell/Hold action? ").lower()
        
        # Construct the AI prompt
        prompt = construct_analysis_prompt(
            agent_state.fgi_data,
            agent_state.coin_information,
            agent_state.investor_type,
            agent_state.risk_strategy,
            agent_state.cryptonews_info,
            agent_state.network
        )
        
        # Send prompt to ASI1 reasoning agent
        await ctx.send(REASON_AGENT, ASI1Request(query=prompt))
        logger.info("Sent ASI1Request for trading signal")
    except Exception as e:
        logger.error(f"Error querying ASI1 model: {e}")
        raise AgentCommunicationError(f"Failed to communicate with ASI1 Reasoning Agent: {e}")


def construct_analysis_prompt(
    fgi_data: FGIResponse, 
    coin_data: CoinResponse, 
    investor_type: InvestorType, 
    risk_strategy: RiskStrategy,
    crypto_news: CryptonewsResponse,
    network: BlockchainType
) -> str:
    """
    Construct a prompt for the ASI1 reasoning agent.
    
    Args:
        fgi_data: Fear & Greed Index data
        coin_data: Cryptocurrency market data
        investor_type: User's investor profile
        risk_strategy: User's risk strategy
        crypto_news: Crypto news data
        network: Selected blockchain network
        
    Returns:
        str: Formatted prompt for ASI1 analysis
    """
    return f'''    
    Consider the following factors:
    
    Fear Greed Index Analysis - {fgi_data}
    Coin Market Data - {coin_data}
    User's type of investing - {investor_type}
    User's risk strategy - {risk_strategy}
    
    Most recent crypto news - {crypto_news}
    
    You are a crypto expert, who is assisting the user to make the most meaningful decisions, to gain the most revenue. 
    Given the following information, respond with one word, either "SELL", "BUY" or "HOLD" native token from {network.value} network.
    '''


@agent.on_message(model=ASI1Response)
async def handle_asi1_response(ctx: Context, sender: str, msg: ASI1Response) -> None:
    """
    Handle the response from the ASI1 reasoning agent and take appropriate action.
    
    Args:
        ctx: Agent context
        sender: Sender agent address
        msg: ASI1 reasoning response with trading decision
    """
    logger.info(f"Received ASI1Response from {sender} with decision: {msg.decision}")
    
    # Process the decision
    if TradingSignal.SELL.value in msg.decision:
        logger.critical("SELL SIGNAL DETECTED!")
        print("SELL")
        # Future enhancement: start search and run of ETH to USDC swap agent
    elif TradingSignal.BUY.value in msg.decision:
        logger.critical("BUY SIGNAL DETECTED!")
        print("BUY")
        # Future enhancement: start search and run of USDC to ETH swap agent
    else:
        logger.info("HOLD decision received.")
        print("HOLD")


# Application entry point
if __name__ == "__main__":
    try:
        logger.info("Starting the agent...")
        agent.run()
    except KeyboardInterrupt:
        logger.info("Agent stopped by user")
    except Exception as e:
        logger.critical(f"Error starting the agent: {e}")
        sys.exit(1)
```

## Key Improvements

This refactored version includes:

1. **Type Annotations**: Added proper type hints for all functions, variables, and parameters
2. **Improved Error Handling**: Created custom exception classes for agent-specific errors
3. **Environment Variables**: Used for configuration with appropriate defaults
4. **PEP 8 Styling**: Aligned with Python style guidelines and consistent formatting
5. **Comprehensive Docstrings**: Added detailed documentation for all functions, classes, and methods
6. **Organized Imports**: Grouped and sorted imports by standard, third-party, and local modules
7. **Descriptive Variable Names**: Used more descriptive names throughout the code
8. **Enhanced Modularity**: Split concerns into specialized functions
9. **Enums for Constants**: Added enum classes for blockchain, investor types, risk strategies, and signals
10. **State Management**: Created a dedicated dataclass for managing the agent's state
11. **Improved Logging**: Enhanced logging configuration with both console and file handlers
12. **Proper Configuration**: Separated configuration from logic using environment variables

The improved code maintains the same functionality and agent communication flow while providing better organization, error handling, and maintainability. 